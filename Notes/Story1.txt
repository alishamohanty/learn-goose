Story 1: Create a landing page for Redis Implementation

Requirements: Server that would visually showcase the number of 
 - enqueued jobs
 - scheduled jobs
 - periodic jobs
 - dead jobs

- Create a page that would visually showcase the UI for the same (done)

Approach 1
-------
- stringified html returned as response
- inorder to have dynamic data, the html would be broken down at proper sections to capture the data.
- how to render an image (goose logo)?
- how to render javascript?
	embed js in the stringified html itself 
- reuse of the components like navbar?
	can't be reused, code have to be reimplemented everytime
- how to change the ui theme? (not so important now)
    different components with the same code.

cons
----
- difficult to parse HTML while coding
- appending dynamic data becomes difficult
- components reuse becomes difficult
- rendering javascript?
	- inline js since the html is string value
	- external js
		- host the js somewhere and pass the link in the script tag
		- while serving js from the same server, use static file handling so that js is loaded when loaded.
	
Approach 2
--------
- Different HTML file
- Since the file is directly loaded, adding dynamic data to the file if not possible.

- cons
-----
 - no direct way of adding dynamic data into the index.html since the entire file in rendered as it is.

- Hence we would require some sort of templating engine for this 
	-selmer
	-hiccup
- we would write the code in the clojure with the dynamic data and before returing response to the client convert into html.


Approach 3
-------
- Hiccup + css + js/cljs

- Hiccup does not have any dependency, so its light weight
- UI can be broken down to reusable components
- Easy of adding dynamic data

- use of cljs will enable to write idiomatic clojure code instead of vanilla js (which will exist most likely in resources folder i.e outside of src).
- Hiccup does not have any dependency, so its lightweight

cons
----
- Can lead to more boilerplate code
- Handling local/global state becomes cumbersome
- Framework like reagent will automatically re-render on component change, where as incase of hiccup the state updates needs to be manually handled.


pros of using reagent over hiccup
------
reagent uses automatic re-rendering of components when the associated data is changed, whereas hiccup requires manual intervention. Makes the code more verbose.

efficient dom updates and access to react ecosystem.

the decision of hiccup vs reagent lies in how many times state changes happen, how much 

what are different state updates in Goose:
------
- In enqueued page
	- apply filter on type, id, execute-fn-symbol
	- delete 1/multiple job/s
	- prioritise 1/multiple job/s

- In Scheduled page
	- apply filter on type, id, queue, execute-fn-symbol
	- delete 1/multiple job/s
	- prioritise 1/multiple job/s

- In periodic page
	- apply filter by job's name
	- delete 1/multiple jobs

- In dead page
	- apply filter by job's type, id, queue, execute-fn-symbol
	- delete 1/multiple job/s
	- replay 1/multiple job/s

Approach 4
----------
- Clojure-script / reagent
- Reagent: Helps you write frontend in react using clojurescript
		   Write efficient components using cljs functions & data with hiccup like syntax

- Fast
- Easier to write/maintain frontened with state and data that changes frequently and require a lot of re-rendering

  cons
  ----
  - lot of dependencies
  		- reagent
  		- cljs/react
  		- cljs/react-dom 

  - Understanding dependencies requirement 
  	  - Do we require reagent, cljs/react and cljs/react-dom in the dependencies list or its enough for the dev dependencies(
  	  	- (need to figure out)
  		- Once figwheel builds the clojurescript files, then the compiled version will be served by the server.


Requirements related to GOOSE CONSOLE UI
------------
- Does our app have a lot of state?
	- less likely. 
- What are the different operations performed on job/jobs
	- View
	- Delete
	- Delete multiple
	- Prioritise
	- Prioritise multiple
	- Replay
	- Replay multiple
	- Filter based on type, execute-fn-symbol, queue, id
	- Change API limit

- What are some of the javascript usage?
	- Popup dialog when deleting job/s 
	- Store the selected filter
		(filters can be appended in the url to avoid storing state in the app)
	- Submit/Apply a filter
		- through form submission?
	- Delete multiple jobs
	- Prioritise multiple jobs
	- Replay a job
	- Add a limit

- What are the different post/pre views when performing various actions said above?
	- Delete a job
		Pre: The jobs page which will be deleted
		Post Deletion: Back to jobs page
	   Ex: If a scheduled job is deleted, then it will redirect to scheduled page
	- Delete multiple jobs
	    Pre: Jobs page
	    Post: Jobs page
	   How to handle?
	    - If a job is deleted, it can send a request to delete and re-render with updated data.
	- Prioritise a job
		Pre: The Job page which is prioritised
		Post: Jobs page
	- API limit for filter query needs to be saved in the URL or need to be locally stored (if needed to be persisted localstorage)



Questions | Understanding:
----------
- What is reagent?
   - Enables writing React using Clojurescript
   - We write our programs in clojurescript. Tools like Figwheel or leiningen builds the clojurescript to html, javscript and makes it available to be used for our server.

- What is reframe?
	- Re-frame is a ClojureScript framework for building client-side web applications in a functional and reactive style.
	- Leverages Reagent (a minimalistic React wrapper) for its view layer, but adds a structured and disciplined approach to managing state and side-effects.
	- Re-frame organizes an application into a unidirectional data flow, which makes state changes predictable and understandable.  - It's well-suited for complex applications with many moving parts, offering a robust approach to managing app state and behavior.

- What is hiccup?
	- Represents Html in Clojure

- What is clojurescript?
	
	 - It is a compiler that compiles clojure into javascript.
	 - Clojurescript compiles clojure to js in browser or node
	 - Uses Google's Closure Compile Tool

- What is the use of clojurescript?
- Does the landing page require javascript? Not right now.

- What type of structure will be brought if we combine use reagent over hiccup + clojurescript?

TODO:
-----
- Create a dummy project to understand what is clojurscript? (done)
- Use hiccup and see how both of them works? (done)
- Use reagent to see, how it harness it?
	- Why does goose require reagent that adds additional benefit over hiccup + clojurescript?

-----------







